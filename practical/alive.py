# -*- coding: utf-8 -*-
"""alive.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tbd5lYVHB4A99t5qflAsFVtp7zsNXjFs
"""

import pandas as pd
import numpy as np
from sklearn.linear_model import LogisticRegression

train=pd.read_csv(r'C:\Users\pawan_300\Desktop\Project work\ml files\titanic\train.csv')
test=pd.read_csv(r'C:\Users\pawan_300\Desktop\Project work\ml files\titanic\test.csv')

train['Age']=train['Age'].ffill(axis=0)
test['Age']=test['Age'].ffill(axis=0)
test['Fare']=test['Fare'].ffill(axis=0)
train['Fare']=train['Fare'].ffill(axis=0)
test['Embarked']=test['Embarked'].ffill(axis=0)
train['Embarked']=train['Embarked'].ffill(axis=0)

Sex={'male':0,'female':1}
train['Sex']=[Sex[item] for item in train['Sex']]
test['Sex']=[Sex[item] for item in test['Sex']]

e={'S':0,'C':1,'Q':2}
train['Embarked']=[e[item] for item in train['Embarked']]
test['Embarked']=[e[item] for item in test['Embarked']]

x=np.array([train['Pclass'],train['Sex'],train['Age'],train['SibSp'],train['Parch'],train['Fare']]).T
y=np.array([train['Survived']]).T

"""## Using library"""

clf = LogisticRegression(random_state=0, solver='lbfgs',multi_class='ovr').fit(x, y)

clf.score(x,y)

clf.coef_

test_x=np.array([test['Pclass'],test['Sex'],test['Age'],test['SibSp'],test['Parch'],test['Fare']]).T

test_y=clf.predict(test_x)

def solution(sol):
    Id=test["PassengerId"]
    df=pd.DataFrame(sol,Id)
    df.columns=["Survived"]
    df.to_csv(r"C:\Users\pawan_300\Desktop\solution.csv")

solution(test_y)

"""## Hard coded"""

def sigmoid(x,t):
    return(1/(1+np.exp(np.negative(x.dot(t.T)))))

def regression(n):
    m=train.shape[0]
    theta=[0]*x.shape[1]
    theta=np.matrix(theta)
    j=[]
    for i in range(n):
        l=sigmoid(x,theta)
        j.append(1/(2*m)*(-np.sum(y.T.dot(np.log(l))+(1-y).T.dot(np.log(1-l)))))
        if((j[i])<0.00001):
            break
        else:
            theta=gradient(theta.T)
    return(theta)

def gradient(theta):
    l_rate=0.01
    theta=theta+l_rate*1/x.shape[0]*(x.T.dot(y-sigmoid(x,theta.T)))
    return(theta.T)

def predict(n):
    sol=[]
    theta=regression(n)
    probability=sigmoid(test_x,theta)
    for i in range(len(probability)):
        if(probability[i]>0.5):
            sol.append(1)
        else:
            sol.append(0)
    sol=np.array(sol)
    return(sol)

predict(100000)

sol=predict(1000)
solution(sol)

from sklearn.svm import LinearSVC

clf = LinearSVC(random_state=0, tol=1e-5).fit(x, y)

test_y=clf.predict(test_x)

solution(test_y)

